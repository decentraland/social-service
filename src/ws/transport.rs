use std::{
    collections::HashMap,
    sync::{
        atomic::{AtomicBool, Ordering},
        Arc,
    },
};

use dcl_rpc::{
    server::RpcServer,
    stream_protocol::GeneratorYielder,
    transports::{Transport, TransportError, TransportMessage},
};

use futures_util::{
    stream::{SplitSink, SplitStream},
    SinkExt, StreamExt,
};

use tokio::sync::{Mutex, RwLock};

use warp::{
    http::header::HeaderValue,
    ws::{Message as WarpWSMessage, WebSocket},
    Filter, Rejection, Reply,
};

use crate::{
    components::notifications::{
        init_events_channel_publisher, init_events_channel_subscriber, RedisChannelPublisher,
        RedisChannelSubscriber,
    },
    components::{
        configuration::{Config, Server},
        database::DatabaseComponent,
        notifications::{ChannelSubscriber, EVENT_UPDATES_CHANNEL_NAME},
        redis::Redis,
        synapse::SynapseComponent,
        users_cache::UsersCacheComponent,
    },
    friendships::{
        subscribe_friendship_events_updates_response, FriendshipEventResponses,
        FriendshipsServiceRegistration, SubscribeFriendshipEventsUpdatesResponse,
    },
    domain::address::Address,
    notifications::Event,
};

use lazy_static::lazy_static;
use prometheus::{self, Encoder, IntCounterVec, Opts, Registry};

use super::{service::friendships_service, metrics::{metrics_handler, register_metrics}};



type ReadStream = SplitStream<WebSocket>;
type WriteStream = SplitSink<WebSocket, WarpWSMessage>;

pub struct WarpWebSocketTransport {
    read: Mutex<ReadStream>,
    write: Mutex<WriteStream>,
    ready: AtomicBool,
}

impl WarpWebSocketTransport {
    /// Crates a new [`WebSocketTransport`] from a Websocket connection generated by [`WebSocketServer`] or [`WebSocketClient`]
    pub fn new(ws: WebSocket) -> Self {
        let (write, read) = ws.split();
        Self {
            read: Mutex::new(read),
            write: Mutex::new(write),
            ready: AtomicBool::new(false),
        }
    }
}

#[async_trait::async_trait]
impl Transport for WarpWebSocketTransport {
    async fn receive(&self) -> Result<TransportMessage, TransportError> {
        match self.read.lock().await.next().await {
            Some(Ok(message)) => {
                if message.is_binary() {
                    let message_data = message.into_bytes();
                    return Ok(message_data);
                } else {
                    // Ignore messages that are not binary
                    log::error!("> WebSocketTransport > Received message is not binary");
                    return Err(TransportError::NotBinaryMessage);
                }
            }
            Some(Err(err)) => {
                println!("Failed to receive message {err:?}");
            }
            None => {
                println!("No message")
            }
        }
        println!("Closing transport...");
        self.close().await;
        Err(TransportError::Closed)
    }

    async fn send(&self, message: Vec<u8>) -> Result<(), TransportError> {
        let message = WarpWSMessage::binary(message);
        match self.write.lock().await.send(message).await {
            Err(err) => {
                log::error!(
                    "> WebSocketTransport > Error on sending in a ws connection {}",
                    err.to_string()
                );

                let error = TransportError::Internal(Box::new(err));

                Err(error)
            }
            Ok(_) => Ok(()),
        }
    }

    async fn close(&self) {
        match self.write.lock().await.close().await {
            Ok(_) => {
                self.ready.store(false, Ordering::SeqCst);
            }
            _ => {
                log::error!("Couldn't close transport")
            }
        }
    }
}
